#!/usr/bin/env python
import math
from multiprocessing.connection import wait
from os import waitstatus_to_exitcode
from std_msgs.msg import Header, String
import smach_ros

from smach import State, StateMachine

from typing import List
import rospy

from aurmr_tasks.common.tahoma import Tahoma
from aurmr_tasks.common import motion, perception
from aurmr_tasks import interaction
from geometry_msgs.msg import PoseStamped, Pose, Point, Quaternion
from tf_conversions import transformations
import aurmr_tasks.common.control_flow as cf
from aurmr_tasks.pod import load_sm

from aurmr_tasks.srv import StowRequest, PickRequest
from aurmr_tasks.srv import MultiplePickRequest
from aurmr_tasks.msg import PickStatus
from aurmr_perception.util import vec_to_quat_msg, I_QUAT
from aurmr_tasks.common.states import Wait
from aurmr_tasks.common import motion_storm
import std_msgs
TARGET_BIN_ID = "001"
TARGET_OBJECT_ID = "XYZ"

align_to_tote_orientation = transformations.quaternion_from_euler(math.pi, 0, 0)
align_to_bin_quat = vec_to_quat_msg(align_to_tote_orientation)

quat_obj = Quaternion(x=0, y=0.707, z=0, w=0.707)
TOTE_APPROACH_POSE = PoseStamped(header=Header(frame_id="base_link"), pose=Pose(position=Point(x=0.0, y=-0.45,z=1.1), orientation=align_to_bin_quat ))

# TOTE_APPROACH_POSE = PoseStamped(header=Header(frame_id="base_link"), pose=Pose(position=Point(x=.108, y=-.514,z=0.884), orientation=align_to_bin_quat))

class PublishStatus(State):
    def __init__(self, publisher, wait_time=0):
        State.__init__(self, outcomes=['succeeded'], input_keys=["status", "start_time", "target_object_id"])
        self.publisher=publisher
        self.wait_time = wait_time
    def execute(self, userdata):
        now = rospy.get_rostime()
        now = now.secs + now.nsecs*10**(-9)
        time_delta = now - userdata["start_time"] 


        msg = PickStatus()
        msg.status = userdata["status"]
        msg.object_id = userdata["target_object_id"]
        msg.time = time_delta
        # self.publisher.publish("test")
        self.publisher.publish(msg)
        rospy.sleep(self.wait_time)
        return "succeeded"

class RecordTime(State):
    def __init__(self):
        State.__init__(self, outcomes=['succeeded'], output_keys=["start_time"])
    
    def execute(self, userdata):
        now = rospy.get_rostime()
        userdata["start_time"] = now.secs + now.nsecs*10**(-9)
        return "succeeded"
        
class WaitForPickStow(State):
    def __init__(self):
        State.__init__(self, outcomes=['pick', 'stow', 'done'], output_keys=["request"])
        self.stow_service = rospy.Service('~stow', StowRequest, self.stow_cb)
        self.pick_service = rospy.Service('~pick', PickRequest, self.pick_cb)
        self.multi_pick_service = rospy.Service('~multiple_pick', MultiplePickRequest, self.multiple_pick_cb)
        self.do_stow = False
        self.do_pick = False
        self.execution_done = False
        self.first = True
        self.request = None
        self.success = False

    def stow_cb(self, request: StowRequest):
        rospy.loginfo("STOW REQUEST: " + str(request))
        self.request = request
        self.do_stow = True
        self.execution_done = False
        while not self.execution_done and not rospy.is_shutdown():
            rospy.sleep(.1)
        return {"success": self.success}

    def multiple_pick_cb(self, requests: MultiplePickRequest):
        for i in range(len(requests.bin_ids)):
            r = PickRequest()
            r.object_id = requests.object_ids[i]
            r.bin_id = requests.bin_ids[i]
            if self.pick_cb(r).get('success', None):
                # ..todo report success
                pass
        return True

    def pick_cb(self, request: PickRequest):
        rospy.loginfo("PICK REQUEST: " + str(request))
        self.request = request
        self.do_pick = True
        self.execution_done = False
        while not self.execution_done and not rospy.is_shutdown():
            rospy.sleep(.1)
        return {"success": self.success}

    def execute(self, userdata):
        print(self.first)
        print("WAITFORPICKANDSTOW")
        #TODO: Check if the self.first variable is necessary
        if not self.first:
            self.execution_done = True
            self.do_stow = False
            self.do_pick = False
        else:
            self.first = False

        while not self.do_stow and not self.do_pick and not rospy.is_shutdown():
            rospy.sleep(.1)

        # userdata["request"] = ["3f", "can"]
        userdata["request"] = [self.request.bin_id, self.request.object_id]
        if self.do_stow:
            print("STOWING")
            return "stow"
        elif self.do_pick:
            return "pick"
        else:
            return "done"

def main():
    rospy.init_node("aurmr_demo")
    pose_pub_test = rospy.Publisher("/tote_drop", PoseStamped, queue_size=5, latch=True)
    status_pub = rospy.Publisher("/demo_status", PickStatus, queue_size=5, latch=True)
    TOTE_APPROACH_POSE.header.stamp = rospy.Time.now()
    pose_pub_test.publish(TOTE_APPROACH_POSE)
    simulation = rospy.get_param("/use_sim_time", False)
    State.simulation = simulation
    robot = Tahoma(simulation)
    print("here")
    demo_sm = StateMachine(["done"], input_keys=[], output_keys=[])
    pick_sm = StateMachine(["done"], input_keys=["request"], output_keys=[])
    stow_sm = StateMachine(["done"], input_keys=["request"], output_keys=[])

    # stows = [["4f", "mouthwash"], ["4f", "soda"], ["4f", "syrup"]]
    # stows = [["3f", "mouthwash"], ['3f', 'lysol'], ['2f', 'box']]
    # picks = [["3f", "lysol"], ['2f', 'box'], ['3f', 'mouthwash']]

    pose_drop = PoseStamped()
    pose_drop.header=std_msgs.msg.Header(frame_id='pod_base_link')
    pose_drop.pose.orientation = Quaternion(0.7071068, 0, 0, 0.7071068)
    pose_drop.pose.position = Point(x=0.0, y=0.32, z=0.9)

    # pose_pre_grasp = PoseStamped()
    # pose_pre_grasp.header=std_msgs.msg.Header(frame_id='pod_base_link')
    # pose_pre_grasp.pose.orientation = Quaternion(x=0, y=1, z=0, w=0)
    # pose_pre_grasp.pose.position = Point(x=0.33, y=1.23, z=-0.4)


    THRUST_DISTANCE = 0.23

    with demo_sm:

        with pick_sm:
            StateMachine.add_auto("RECORD_TIME", RecordTime(), ["succeeded"])
            cf.splat_auto("SPLAT_PICK", "request", ["target_bin_id", "target_object_id"])
            StateMachine.add("GET_GRASP_POSE", perception.GetGraspPose(robot.tf2_buffer, pre_grasp_offset=.09),    
                            {"succeeded": "PUBLISH_CURRENTLY_PICKING", "aborted":"PASS", "preempted":"PASS"})
            StateMachine.add("PASS", PublishStatus(status_pub, wait_time=3), {"succeeded": "done"})
            StateMachine.add_auto("PUBLISH_CURRENTLY_PICKING", PublishStatus(status_pub), ["succeeded"])
            StateMachine.add_auto("REMAP_PRE_GRASP_POSE", cf.input_to_output("pre_grasp_pose", "pose"), ["succeeded"])
            StateMachine.add_auto("TF_TO_STORM", motion_storm.ToStormFrame(), ["succeeded"])
            StateMachine.add_auto("MOVE_TO_PRE_GRASP", motion_storm.MoveEndEffectorToPoseStorm(), ["succeeded", "aborted"])
            
            # StateMachine.add_auto('MOVE_INTO_POD',
            #                   motion_storm.MoveEndEffectorInLineByDistStorm(dist=[THRUST_DISTANCE,0,0] , quat=[0, 0.7071068, 0, 0.7071068], use_force=True, use_gripper=True),
            #                   ["succeeded", "aborted"])
            # StateMachine.add_auto('MOVE_UP_POD',
            #                   motion_storm.MoveEndEffectorInLineByDistStorm(dist=[0,0,-0.1] , quat=[0, 0.7071068, 0, 0.7071068], use_force=False, use_gripper=False),
            #                   ["succeeded", "aborted"])
            # StateMachine.add_auto('MOVE_OUT_POD',
            #                   motion_storm.MoveEndEffectorInLineByDistStorm(dist=[-THRUST_DISTANCE,0,0], quat=[0, 0.7071068, 0, 0.7071068 ] , use_force=False, use_gripper=False),
            #                   ["succeeded", "aborted"])
            # StateMachine.add_auto("MOVE_TO_PRE_TOTE_POSE", motion_storm.MoveEndEffectorToPoseStorm(pose_drop), ["succeeded", "aborted"])

            # StateMachine.add_auto("PICTURE_WAIT", Wait(2), ["succeeded"])
            # StateMachine.add("CHECK_FOR_GRIPPER_ITEM", motion.CheckGripperItem(robot), 
            #                 {"item_detected": "POST_PICK_UPDATE_MASKS", "no_item_detected": "UPDATE_BIN_MASKS"})
            # StateMachine.add("POST_PICK_UPDATE_MASKS", perception.PickObject(),
            #                 {"succeeded": "PUBLISH_PICK_STATUS", "aborted": "PUBLISH_PICK_STATUS", "preempted": "PUBLISH_PICK_STATUS"})
            # StateMachine.add("UPDATE_BIN_MASKS", perception.UpdateBin(),
            #                 {"succeeded": "PUBLISH_PICK_STATUS", "aborted": "PUBLISH_PICK_STATUS", "preempted": "PUBLISH_PICK_STATUS"})
            # StateMachine.add_auto("PUBLISH_PICK_STATUS", PublishStatus(status_pub), ["succeeded"])
            # StateMachine.add("ASK_FOR_GRIPPER_OPEN_TOTE_RELEASE", motion.OpenGripper(robot, return_before_done=True), {"succeeded": "done", "aborted": "done", "preempted": "done"})


        with stow_sm:   
            cf.splat_auto("SPLAT_STOW", "request", ["target_bin_id", "target_object_id"])
            StateMachine.add("MOVE_TO_HIDE", motion_storm.MoveEndEffectorToPoseStorm(pose_drop),
                            {"succeeded": "PRE_PERCEIVE", "aborted": "PICK_FAILED"})
            #TODO: Check that this state actually does anything
            StateMachine.add("PRE_PERCEIVE", perception.CaptureEmptyBin(),
                            {"succeeded": "POST_PERCEIVE", "aborted": "PICK_FAILED", "preempted": "PICK_FAILED"})
            # StateMachine.add("ASK_FOR_BIN_LOAD", interaction.AskForHumanAction(),
            #                 {"succeeded": "POST_PERCEIVE", "aborted": "PICK_FAILED"})
            StateMachine.add("POST_PERCEIVE", perception.StowObject(),
                            {"succeeded": "PICK_SUCCESS", "aborted": "PICK_FAILED", "preempted": "PICK_FAILED"})
            cf.inject_userdata("PICK_FAILED", "done", "status", False)
            cf.inject_userdata("PICK_SUCCESS", "done", "status", True)




        StateMachine.add_auto("MOVE_TO_HIDE", motion_storm.MoveEndEffectorToPoseStorm(pose_drop),  ["succeeded", "aborted"])
        StateMachine.add_auto("CHECK_GRIPPER_CLOSE", motion.CloseGripper(robot, return_before_done=True), ["succeeded", "aborted", "preempted"])
        StateMachine.add_auto("CHECK_GRIPPER_OPEN", motion.OpenGripper(robot, return_before_done=True), ["succeeded", "aborted", "preempted"])
        StateMachine.add_auto("CAPTURE_EMPTY_POD", perception.CaptureEmptyPod(),  ["succeeded"])
        StateMachine.add("WAIT_FOR_COMMAND", WaitForPickStow(), {"stow": "STOW", "pick":"PICK"})
        StateMachine.add("PICK", pick_sm, {"done": "WAIT_FOR_COMMAND"})
        StateMachine.add("STOW", stow_sm, {"done": "WAIT_FOR_COMMAND"})

    rospy.loginfo('Beginning demo SM')

    sis = smach_ros.IntrospectionServer('demo_sm', demo_sm, '/pick')
    sis.start()

    outcome = demo_sm.execute()

    rospy.spin()
    sis.stop()


if __name__ == '__main__':
    main()


