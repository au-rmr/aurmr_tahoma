#!/usr/bin/env python

import random
import std_msgs
import visualization_msgs.msg

import rospy
from smach import State

from aurmr_tasks.common.tahoma import Tahoma

import numpy as np
from geometry_msgs.msg import PoseStamped, Pose, Point, Quaternion
from tf_conversions import transformations

from aurmr_perception.visualization import create_gripper_pose_markers

import copy
from aurmr_tasks.pod import BIN_IDS

def main(x_distance, loop_times):
    # setup simulation 
    rospy.loginfo('Getting robot resources')
    rospy.init_node("analyze_workspace")
    simulation = rospy.get_param("/use_sim_time", False)
    State.simulation = simulation
    robot = Tahoma(simulation)

    # for storing manipulability data over 1 trial (manip %, green, white)
    looped_data = open("looped_Data.csv", "w")
    looped_data.write('manip %, green, white')
    looped_data.write("\n")

    # box and whisker plot file for storing manipulability data over multiple trials 
    box_data = open("boxPlot_data.csv", "a")
    box_data.write("\n")

    # manually change distance everytime program is run 
    box_data.write(str(x_distance) + ", ")

    # add pod collision boxes to planning scene 
    robot.add_pod_collision_geometry()

    # where robot position relative to bin gets hardcoded 
    align_to_bin_orientation = transformations.quaternion_from_euler(-1.57, 0, 0)
    align_to_bin_quat = Quaternion(x=align_to_bin_orientation[0], y=align_to_bin_orientation[1], z=align_to_bin_orientation[2], w=align_to_bin_orientation[3])
    BIN_APPROACH_POSES = []
    BIN_INNER_POSES = []
    for bin_id in BIN_IDS:
        frame_name = f"pod_bin_{bin_id}"
        # change y value in pose, position to alter distance of pre-grasp pose from bin 
        BIN_APPROACH_POSES.append(PoseStamped(header=std_msgs.msg.Header(frame_id=frame_name), pose=Pose(position=Point(x=.125, y=-0.10,z=.07), orientation=align_to_bin_quat)))
        for j in range(10):
            # Get some randomly offset poses in the bin to see if we'll be able to reach the inside
            perturbed_quat = [align_to_bin_quat.x, align_to_bin_quat.y, align_to_bin_quat.z, align_to_bin_quat.w] + np.random.uniform(-.2, .2, 4)
            perturbed_quat /= np.linalg.norm(perturbed_quat)
            perturbed_quat_msg = Quaternion(x=perturbed_quat[0], y=perturbed_quat[1], z=perturbed_quat[2], w=perturbed_quat[3])
            BIN_INNER_POSES.append(PoseStamped(header=std_msgs.msg.Header(frame_id=frame_name), pose=Pose(position=Point(x=.125 + random.uniform(-.1, .1), y=random.uniform(-0,.1),z=.07 + random.uniform(0, .05)), orientation=perturbed_quat_msg)))
    
    for i in range(loop_times):
        print("trail: " + str(i))
        calculate_ik(looped_data, box_data, BIN_APPROACH_POSES, robot)

    looped_data.close()
    box_data.close()

def calculate_ik(file_name, file_name2, approaches, robot):

    REACHABLE_BIN_APPROACHES = []
    MANIPULABLE_APPROACHES = []

    print("Determining approachable bins...")
    
    # cartesian manipulability test for bin approach poses 
    counter = 0
    for approach in enumerate(approaches):

        pose = copy.deepcopy(approach[1])
        manip = robot.compute_ik_cartesian(pose, pose.pose, rospy.Duration(0))

        # not reachable or no viable path to bin pose
        if (len(manip) == 0): 
            print(str(counter) + " has no viable path")

        else: 
            print("cond num " + str(counter) +  " has a solution.") 
            REACHABLE_BIN_APPROACHES.append(approach)

            sorted = copy.deepcopy(manip)
            sorted.sort()
            
            # how skewed is the data towards infinitiy (singularity)? how safely manipulatable is the object? 
            manipThreshold = 400

            if (sorted[len(sorted)-1] >= manipThreshold): 
                print("solution but above manipulability threshold")
            else :
                MANIPULABLE_APPROACHES.append(approach)

        counter = counter + 1

    ratio = len(MANIPULABLE_APPROACHES)/len(REACHABLE_BIN_APPROACHES)

    file_name.write(str(ratio * 100) + ", ")
    file_name2.write(str(ratio * 100) + ", ")
    
    file_name.write(str(len(MANIPULABLE_APPROACHES)) + ", ")
    file_name.write(str(len(REACHABLE_BIN_APPROACHES) - len(MANIPULABLE_APPROACHES)) + "\n")
    
if __name__ == '__main__':
    main(0.677,100)


