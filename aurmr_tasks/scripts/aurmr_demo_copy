#!/usr/bin/env python
import math
from std_msgs.msg import Header
import smach_ros

from smach import State, StateMachine

import rospy

from aurmr_tasks.common.tahoma import Tahoma
from aurmr_tasks.common import motion, perception
from aurmr_tasks import interaction
from geometry_msgs.msg import PoseStamped, Pose, Point, Quaternion
from tf_conversions import transformations
import aurmr_tasks.common.control_flow as cf
from aurmr_tasks.pod import load_sm

from aurmr_tasks.srv import StowRequest, PickRequest
from aurmr_tasks.common.motion import robust_move_to_offset, grasp_move_to_offset
from aurmr_perception.util import vec_to_quat_msg, I_QUAT

TARGET_BIN_ID = "001"
TARGET_OBJECT_ID = "XYZ"

align_to_tote_orientation = transformations.quaternion_from_euler(math.pi, 0, 0)
align_to_bin_quat = vec_to_quat_msg(align_to_tote_orientation)

quat_obj = Quaternion(x=0, y=0.707, z=0, w=0.707)
TOTE_APPROACH_POSE = PoseStamped(header=Header(frame_id="base_link"), pose=Pose(position=Point(x=0.0, y=-0.45,z=1.1), orientation=align_to_bin_quat ))

# TOTE_APPROACH_POSE = PoseStamped(header=Header(frame_id="base_link"), pose=Pose(position=Point(x=.108, y=-.514,z=0.884), orientation=align_to_bin_quat))

class WaitForPickStow(State):
    def __init__(self):
        State.__init__(self, outcomes=['pick', 'stow', 'done'], output_keys=["request"])
        self.stow_service = rospy.Service('~stow', StowRequest, self.stow_cb)
        self.pick_service = rospy.Service('~pick', PickRequest, self.pick_cb)
        self.do_stow = False
        self.do_pick = False
        self.execution_done = False
        self.first = True
        self.request = None
        self.success = False

        

    def stow_cb(self, request: StowRequest):
        self.request = request
        self.do_stow = True
        self.execution_done = False
        while not self.execution_done and not rospy.is_shutdown():
            rospy.sleep(.1)
        return {"success": self.success}

    def pick_cb(self, request: PickRequest):
        self.request = request
        self.do_pick = True
        self.execution_done = False
        while not self.execution_done and not rospy.is_shutdown():
            rospy.sleep(.1)
        return {"success": self.success}

    def execute(self, userdata):
        print(self.first)
        print("WAITFORPICKANDSTOW")
        if not self.first:
            self.execution_done = True
            self.do_stow = False
            self.do_pick = False
        else:
            self.first = False

        while not self.do_stow and not self.do_pick and not rospy.is_shutdown():
            rospy.sleep(.1)
        
        # userdata["request"] = ["3f", "can"]
        userdata["request"] = [self.request.bin_id, self.request.object_id]
        if self.do_stow:
            print("STOWING")
            return "stow"
        elif self.do_pick:
            return "pick"
        else:
            return "done"

def main():
    rospy.init_node("aurmr_demo")
    pose_pub_test = rospy.Publisher("/tote_drop", PoseStamped, queue_size=5, latch=True)
    TOTE_APPROACH_POSE.header.stamp = rospy.Time.now()
    pose_pub_test.publish(TOTE_APPROACH_POSE)
    simulation = rospy.get_param("/use_sim_time", False)
    State.simulation = simulation
    robot = Tahoma(simulation)
    print("here")
    demo_sm = StateMachine(["done"], input_keys=[], output_keys=[])
    pick_sm = StateMachine(["done"], input_keys=["request"], output_keys=[])
    stow_sm = StateMachine(["done"], input_keys=["request"], output_keys=[])

    # stows = [["4f", "mouthwash"], ["4f", "soda"], ["4f", "syrup"]]
    # stows = [["3f", "mouthwash"], ['3f', 'lysol'], ['2f', 'box']]
    # picks = [["3f", "lysol"], ['2f', 'box'], ['3f', 'mouthwash']]


    with demo_sm:
        # StateMachine.add("CLEAR_SCENE_GRASP", motion.ClearCollisionGeometry(robot), {"succeeded": "MOVE_TO_GRASP"})
        # StateMachine.add("SETUP_COLLISION_SCENE_PICK", motion.AddPodCollisionGeometry(robot), {"succeeded": "MOVE_TO_POSE_DROP"})
        with pick_sm:

            cf.splat_auto("SPLAT_PICK", "request", ["target_bin_id", "target_object_id"])
            StateMachine.add("GET_GRASP_POSE", perception.GetGraspPose(robot.tf2_buffer, pre_grasp_offset=.125),
                            {"succeeded": "REMAP_PRE_GRASP_POSE", "aborted": "PICK_FAILED", "preempted": "PICK_FAILED"})
            StateMachine.add("REMAP_PRE_GRASP_POSE", cf.input_to_output("pre_grasp_pose", "pose"),
                            {"succeeded": "MOVE_TO_PRE_GRASP"})
            StateMachine.add("MOVE_TO_PRE_GRASP", motion.MoveEndEffectorToPose(robot),
                            {"succeeded": "CLEAR_SCENE_GRASP", "aborted": "PICK_FAILED", "preempted": "PICK_FAILED"})
            # remove pod collision before doing cartesien move
            StateMachine.add("CLEAR_SCENE_GRASP", motion.ClearCollisionGeometry(robot), {"succeeded": "OPEN_BEFORE_GRASP", "aborted": "PICK_FAILED"})
            StateMachine.add("OPEN_BEFORE_GRASP", motion.OpenGripper(robot),
                            {"succeeded": "MOVE_TO_GRASP", "aborted": "MOVE_TO_GRASP", "preempted": "PICK_FAILED"})
            StateMachine.add("MOVE_TO_GRASP", grasp_move_to_offset(robot, (0, 0, 0.210)),
                            {"succeeded": "LIFT_OBJ", "aborted": "LIFT_OBJ", "preempted": "PICK_FAILED"})
            StateMachine.add("LIFT_OBJ", robust_move_to_offset(robot, (0, 0, 0.056), 'base_link'),
                            {"succeeded": "RETRACT_ARM", "aborted": "PICK_FAILED", "preempted": "PICK_FAILED"})
            StateMachine.add("RETRACT_ARM", robust_move_to_offset(robot, (0, 0, -0.25)),
                            {"succeeded": "SETUP_COLLISION_SCENE_PICK", "aborted": "SETUP_COLLISION_SCENE_PICK", "preempted": "PICK_FAILED"})
            # add back pod collision before after cartesien move
            StateMachine.add("SETUP_COLLISION_SCENE_PICK", motion.AddPodCollisionGeometry(robot), {"succeeded": "ADD_IN_HAND_COLLISION_BOX", "aborted": "PICK_FAILED"})
            StateMachine.add("ADD_IN_HAND_COLLISION_BOX", motion.AddInHandCollisionGeometry(robot),
                            {"succeeded": "MOVE_TO_PRE_TOTE_POSE", "aborted": "PICK_FAILED"})
            StateMachine.add("MOVE_TO_PRE_TOTE_POSE", motion.MoveToJointAngles(robot, "drop_hide"),
                            {"succeeded": "ASK_FOR_GRIPPER_OPEN_TOTE_RELEASE", "aborted": "ASK_FOR_GRIPPER_OPEN_TOTE_RELEASE"})
            StateMachine.add("ASK_FOR_GRIPPER_OPEN_TOTE_RELEASE", motion.OpenGripper(robot), 
                            {"succeeded": "POST_PICK", "aborted": "PICK_FAILED", "preempted": "PICK_FAILED"})
            StateMachine.add("POST_PICK", perception.PickObject(),
                            {"succeeded": "PICK_SUCCESS", "aborted": "PICK_FAILED", "preempted": "PICK_FAILED"})
            cf.inject_userdata("PICK_FAILED", "done", "status", False)
            cf.inject_userdata("PICK_SUCCESS", "done", "status", True)


        with stow_sm:   
            cf.splat_auto("SPLAT_STOW", "request", ["target_bin_id", "target_object_id"])
            StateMachine.add("MOVE_TO_HIDE", motion.MoveToJointAngles(robot, "drop_hide"),
                            {"succeeded": "PRE_PERCEIVE", "aborted": "PICK_FAILED"})
            StateMachine.add("PRE_PERCEIVE", perception.CaptureEmptyBin(),
                            {"succeeded": "POST_PERCEIVE", "aborted": "PICK_FAILED", "preempted": "PICK_FAILED"})
            # StateMachine.add("ASK_FOR_BIN_LOAD", interaction.AskForHumanAction(),
            #                 {"succeeded": "POST_PERCEIVE", "aborted": "PICK_FAILED"})
            StateMachine.add("POST_PERCEIVE", perception.StowObject(),
                            {"succeeded": "PICK_SUCCESS", "aborted": "PICK_FAILED", "preempted": "PICK_FAILED"})
            cf.inject_userdata("PICK_FAILED", "done", "status", False)
            cf.inject_userdata("PICK_SUCCESS", "done", "status", True)



        StateMachine.add_auto("CLEAR_SCENE", motion.ClearCollisionGeometry(robot), ["succeeded", "aborted"])
        StateMachine.add_auto("SETUP_COLLISION_SCENE", motion.AddPodCollisionGeometry(robot), ["succeeded", "aborted"])
        StateMachine.add_auto("MOVE_TO_HIDE", motion.MoveToJointAngles(robot, "drop_hide"),  ["succeeded", "aborted"])
        StateMachine.add_auto("CAPTURE_EMPTY_POD", perception.CaptureEmptyPod(),  ["succeeded"])
        StateMachine.add("WAIT_FOR_COMMAND", WaitForPickStow(), {"stow": "STOW", "pick":"PICK"})
        StateMachine.add("PICK", pick_sm, {"done": "WAIT_FOR_COMMAND"})
        StateMachine.add("STOW", stow_sm, {"done": "WAIT_FOR_COMMAND"})

    rospy.loginfo('Beginning demo SM')

    sis = smach_ros.IntrospectionServer('demo_sm', demo_sm, '/pick')
    sis.start()

    outcome = demo_sm.execute()

    rospy.spin()
    sis.stop()


if __name__ == '__main__':
    main()


