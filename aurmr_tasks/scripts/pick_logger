#!/usr/bin/env python3
import time
import os
import rospy


import rospy
import message_filters

from smach_msgs.msg import SmachContainerStatus
from typing import List
import os

import logging

import subprocess
import signal

import atexit
import psutil

import rospy
import datetime

import threading

# This is an internal high-capacity drive, so we should only need to clear it once before the runs
# /data is a network crossmount (see /etc/fstab). If it's not mounted, `sudo mount -a`
BAG_STORAGE_PATH = "/data/datasets/2023-12-nick-logging"
BACKUP_RECORDING_PATH = "/home/aurmr/bag_recording_failover"

TOPICS_TO_RECORD = [
    "/audio/audio",
    "/audio/audio_info",
    "/aurmr/hri/retry_grasp/goal",
    "/aurmr/hri/retry_grasp/result",
    "/aurmr_perception/detected_masks",
    "/aurmr_perception/labeled_images",
    "/aurmr_perception/colored_images",
    "/camera_lower_right/depth/camera_info",
    "/camera_lower_right/depth_to_rgb/camera_info",
    "/camera_lower_right/rgb/camera_info",
    "/camera_lower_right/rgb_to_depth/camera_info",
    "/demo_sm/smach/container_status",
    "/grasp_detection/detected_grasps",
    "/grasp_detection/detected_pts",
    "/joint_states",
    "/robot_description",
    "/robot_status",
    "/rosout_agg",
    "/stand_camera/camera_info",
    "/stand_camera/image_raw",
    "/tf",
    "/tf_static",
    "/vacuum_gripper_control/status",
    "/wrench"
    ]

record_state_windows = [("MOVE_TO_PRE_GRASP", "PICTURE_WAIT")]

class ROSBagRecorder:
    """
    Recorder for rosbag

    adapted from https://answers.ros.org/question/10714/start-and-stop-rosbag-within-a-python-script/
    """

    def __init__(self, name: str, path: str, topic_names: List[str], finished_handler=None):
        self.topic_names = topic_names
        self.name = name
        self.path = path
        os.makedirs(self.path, exist_ok=True)
        self.process = None
        self.finished_handler = finished_handler
        # Prevent runaway bag recordings by always stopping on exit
        atexit.register(self.stop)

    def start(self) -> bool:
        topics = " ".join(self.topic_names)
        timestamp_str = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
        self.file_name =  f"{self.name}_{timestamp_str}"
        cmd = f"rosbag record -O {self.file_name} -j {topics}"
        rospy.loginfo("Recording the following topics %s", topics)
        self.process = subprocess.Popen(
            cmd, stdin=subprocess.PIPE, shell=True, cwd=self.path
        )
        # Prevent runaway bags
        self._timeout = threading.Timer(30.0, self.stop).start()
        return True
    
    @property
    def active(self) -> bool:
        return self.process is not None


    def stop(self) -> bool:
        if self.process:
            rospy.loginfo(f"Signaling process with PID {self.process.pid}")

            process = psutil.Process(self.process.pid)

            procs = process.children(recursive=True)
            for sub_process in procs:
                sub_process.send_signal(signal.SIGINT)

            _gone, alive = psutil.wait_procs(procs, timeout=12)

            if len(alive) > 0:
                rospy.loginfo(f"Processes still alive {alive}. Sending terminate signal")
                for sub_process in alive:
                    sub_process.terminate()

                _gone, alive = psutil.wait_procs(procs, timeout=24)
                if len(alive) > 0:
                    rospy.loginfo(f"Processes still alive {alive}. Sending kill signal")
                    for sub_process in alive:
                        sub_process.kill()

            self.process.terminate()
            try:
                self.process.wait(timeout=10)
            except psutil.TimeoutExpired:
                rospy.logerr("Unable to terminate process.")
                self.process.kill()

            self.process = None
            if self.finished_handler:
                self.finished_handler(os.path.join(self.path, self.file_name + ".bag"))
            # Make sure we don't get called again
            atexit.unregister(self.stop)
            return True

        rospy.logwarn("No active rosbag recording")
        return False

class StatemachineTrigger:
    """
    Trigger based on the current state machine
    """

    def __init__(self, recorder_factory):

        topic_name = "/demo_sm/smach/container_status"
        subscriber = message_filters.Subscriber(topic_name, SmachContainerStatus)

        subscriber.registerCallback(self.on_new_state)

        self._recorder_factory = recorder_factory
        self.recorder = None

        self._recording_window = None

    def on_new_state(self, msg):

        if not msg.active_states:
            return

        if msg.info != "HEARTBEAT":
            rospy.loginfo("Active states %s", msg.active_states)

        # We're actively recording, waiting for end trigger
        if self._recording_window and self.recorder and self.recorder.active:
            window_end = self._recording_window[1]
            if window_end in msg.active_states:
                rospy.loginfo("recording ended by state %s", window_end)
                self.recorder.stop()
                self.recorder = None
                self._recording_window = None
            return
        # Must not have been triggered yet
        for (window_start, window_end) in record_state_windows:
            if window_start in msg.active_states:
                rospy.loginfo("recording started by state %s", window_start)
                self.recorder = self._recorder_factory()
                self.recorder.start()
                self._recording_window = (window_start, window_end)
                return


def main(path, config_file):
    rospy.init_node("pick_logger")

    # Store all bags for this run in a timestamped dir inside the configured path
    launch_timestamp = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
    bags_path = os.path.join(path, launch_timestamp)
    os.makedirs(bags_path)
    rospy.loginfo(f"Started new logging directory at {bags_path}")

    i = 0
    def make_recorder():
        nonlocal i
        path_to_use = bags_path
        i += 1
        if not os.path.isdir(path):
            path_to_use = os.path.join(BACKUP_RECORDING_PATH, launch_timestamp)
        return ROSBagRecorder(f"{i}", path_to_use, TOPICS_TO_RECORD)

    trigger = StatemachineTrigger(make_recorder)

    rospy.spin()

if __name__ == '__main__':
    main(BAG_STORAGE_PATH, None)
