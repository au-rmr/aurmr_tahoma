#!/usr/bin/env python3
import time
import os
import rospy

import logging

import rospy
import message_filters
from rospy_message_converter import message_converter

from smach_msgs.msg import SmachContainerStatus
from typing import List
import os

import logging

import subprocess
import signal

import atexit
import psutil

import rospy
import datetime

# This is an internal high-capacity drive, so we should only need to clear it once before the runs
BAG_STORAGE_PATH = "/media/aurmr/Logging"
BAG_STORAGE_PATH = "/tmp"
# The host should be configured in ~/.ssh/hosts, and the key should be unlocked (or you'll be prompted on the first run)
RSYNC_DESTINATION = "popo:/tmp"

TOPICS_TO_RECORD = [
    "/demo_sm/smach/container_status",
    "/grasp_detection/detected_grasps",
    "/grasp_detection/detected_pts",
    "/robot_description",
    "/robot_status",
    "/rosout",
    "/stand_camera/camera_info",
    "/stand_camera/image_raw",
    "/tf",
    "/tf_static",
    "/wrench"
    ]

record_state_windows = [("MOVE_TO_PRE_GRASP", "MOVE_TO_PRE_TOTE_POSE")]

class ROSBagRecorder:
    """
    Recorder for rosbag

    adapted from https://answers.ros.org/question/10714/start-and-stop-rosbag-within-a-python-script/
    """

    def __init__(self, name: str, path: str, topic_names: List[str], finished_handler=None):
        self.topic_names = topic_names
        self.name = name
        self.path = path
        os.makedirs(self.path, exist_ok=True)
        self.process = None
        self.finished_handler = finished_handler
        # Prevent runaway bag recordings by always stopping on exit
        atexit.register(self.stop)

    def start(self) -> bool:
        topics = " ".join(self.topic_names)
        timestamp_str = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
        self.file_name =  f"{self.name}_{timestamp_str}"
        cmd = f"rosbag record -O {self.file_name} -j {topics}"
        rospy.loginfo("Recording the following topics %s", topics)
        self.process = subprocess.Popen(
            cmd, stdin=subprocess.PIPE, shell=True, cwd=self.path
        )
        return True


    def stop(self) -> bool:
        if self.process:
            rospy.loginfo(f"Signaling process with PID {self.process.pid}")

            process = psutil.Process(self.process.pid)

            procs = process.children(recursive=True)
            for sub_process in procs:
                sub_process.send_signal(signal.SIGINT)

            _gone, alive = psutil.wait_procs(procs, timeout=3)
            if len(alive) > 0:
                rospy.loginfo(f"Processes still alive {alive}. Sending terminate signal")
                for sub_process in alive:
                    sub_process.terminate()

                _gone, alive = psutil.wait_procs(procs, timeout=5)
                if len(alive) > 0:
                    rospy.loginfo(f"Processes still alive {alive}. Sending kill signal")
                    for sub_process in alive:
                        sub_process.kill()

            self.process.terminate()
            try:
                self.process.wait(timeout=3)
            except psutil.TimeoutExpired:
                rospy.logerr("Unable to terminate process.")
                self.process.kill()
            self.finished_handler(os.path.join(self.path, self.file_name + ".bag"))
            # Make sure we don't get called again
            atexit.unregister(self.stop)
            return True

        rospy.logwarn("No active rosbag recording")
        return False


class StatemachineTrigger:
    """
    Trigger based on the current state machine
    """

    def __init__(self, recorder_factory):

        topic_name = "/demo_sm/smach/container_status"
        subscriber = message_filters.Subscriber(topic_name, SmachContainerStatus)

        subscriber.registerCallback(self.on_new_state)

        self._recorder_factory = recorder_factory
        self.recorder = None

        self._recording_window = None

    def on_new_state(self, msg):

        if not msg.active_states:
            return

        if msg.info != "HEARTBEAT":
            rospy.loginfo("Active states %s", msg.active_states)

        # We're actively recording, waiting for end trigger
        if self._recording_window:
            window_end = self._recording_window[1]
            if window_end in msg.active_states:
                rospy.loginfo("recording ended by state %s", window_end)
                self.recorder.stop()
                self.recorder = None
                self._recording_window = None
            return
        # Must not have been triggered yet
        for (window_start, window_end) in record_state_windows:
            if window_start in msg.active_states:
                rospy.loginfo("recording started by state %s", window_start)
                self.recorder = self._recorder_factory()
                self.recorder.start()
                self._recording_window = (window_start, window_end)
                return


def main(path, config_file):
    rospy.init_node("pick_logger")

    # Store all bags for this run in a timestamped dir inside the configured path
    launch_timestamp = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
    bags_path = os.path.join(path, launch_timestamp)
    os.makedirs(bags_path)
    i = 0
    def make_recorder():
        nonlocal i
        i += 1
        def bag_recording_finished(bag_path):
            # Disable host key checknig to avoid a y/n prompt
            cmd = f"rsync -ha -e 'ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=no' {bag_path} {RSYNC_DESTINATION}"
            rospy.loginfo(f"Transfering bag to {RSYNC_DESTINATION} with {cmd}")
            subprocess.Popen(
                cmd, stdin=subprocess.PIPE, shell=True, cwd="/"
            )
        return ROSBagRecorder(f"{i}", bags_path, TOPICS_TO_RECORD, finished_handler=bag_recording_finished)

    trigger = StatemachineTrigger(make_recorder)

    rospy.spin()

if __name__ == '__main__':
    main(BAG_STORAGE_PATH, None)