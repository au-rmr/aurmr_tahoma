#!/usr/bin/env python
import math
from multiprocessing.connection import wait
from os import waitstatus_to_exitcode
from std_msgs.msg import Header, String
import smach_ros

from smach import State, StateMachine

from typing import List
import rospy

from aurmr_tasks.common.tahoma import Tahoma
from aurmr_tasks.common import motion, perception
from aurmr_tasks import interaction
from geometry_msgs.msg import PoseStamped, Pose, Point, Quaternion
from tf_conversions import transformations
import aurmr_tasks.common.control_flow as cf
from aurmr_tasks.pod import load_sm

from aurmr_tasks.srv import StowRequest, PickRequest
from aurmr_tasks.srv import MultiplePickRequest
from aurmr_tasks.common.motion import robust_move_to_offset, grasp_move_to_offset
from aurmr_perception.util import vec_to_quat_msg, I_QUAT
from aurmr_tasks.common.states import Wait
TARGET_BIN_ID = "001"
TARGET_OBJECT_ID = "XYZ"

align_to_tote_orientation = transformations.quaternion_from_euler(math.pi, 0, 0)
align_to_bin_quat = vec_to_quat_msg(align_to_tote_orientation)

quat_obj = Quaternion(x=0, y=0.707, z=0, w=0.707)
TOTE_APPROACH_POSE = PoseStamped(header=Header(frame_id="base_link"), pose=Pose(position=Point(x=0.0, y=-0.45,z=1.1), orientation=align_to_bin_quat ))

# TOTE_APPROACH_POSE = PoseStamped(header=Header(frame_id="base_link"), pose=Pose(position=Point(x=.108, y=-.514,z=0.884), orientation=align_to_bin_quat))

class PublishStatus(State):
    def __init__(self, publisher, wait_time=0):
        State.__init__(self, outcomes=['succeeded'], input_keys=["status"])
        self.publisher=publisher
        self.wait_time = wait_time
    def execute(self, userdata):
        self.publisher.publish("test")
        # self.publisher.publish(userdata["status"])
        rospy.sleep(self.wait_time)
        return "succeeded"
class WaitForPickStow(State):
    def __init__(self):
        State.__init__(self, outcomes=['pick', 'stow', 'done'], output_keys=["request"])
        self.stow_service = rospy.Service('~stow', StowRequest, self.stow_cb)
        self.pick_service = rospy.Service('~pick', PickRequest, self.pick_cb)
        self.multi_pick_service = rospy.Service('~multiple_pick', MultiplePickRequest, self.multiple_pick_cb)
        self.do_stow = False
        self.do_pick = False
        self.execution_done = False
        self.first = True
        self.request = None
        self.success = False


        

    def stow_cb(self, request: StowRequest):
        rospy.loginfo("STOW REQUEST: " + str(request))
        self.request = request
        self.do_stow = True
        self.execution_done = False
        while not self.execution_done and not rospy.is_shutdown():
            rospy.sleep(.1)
        return {"success": self.success}

    def multiple_pick_cb(self, requests: MultiplePickRequest):
        for i in range(len(requests.bin_ids)):
            r = PickRequest()
            r.object_id = requests.object_ids[i]
            r.bin_id = requests.bin_ids[i]
            if self.pick_cb(r).get('success', None):
                # ..todo report success
                pass
        return True
        

    def pick_cb(self, request: PickRequest):
        rospy.loginfo("PICK REQUEST: " + str(request))
        self.request = request
        self.do_pick = True
        self.execution_done = False
        while not self.execution_done and not rospy.is_shutdown():
            rospy.sleep(.1)
        return {"success": self.success}

    def execute(self, userdata):
        print(self.first)
        print("WAITFORPICKANDSTOW")
        if not self.first:
            self.execution_done = True
            self.do_stow = False
            self.do_pick = False
        else:
            self.first = False

        while not self.do_stow and not self.do_pick and not rospy.is_shutdown():
            rospy.sleep(.1)
        
        # userdata["request"] = ["3f", "can"]
        userdata["request"] = [self.request.bin_id, self.request.object_id]
        if self.do_stow:
            print("STOWING")
            return "stow"
        elif self.do_pick:
            return "pick"
        else:
            return "done"

def main():
    rospy.init_node("aurmr_demo")
    pose_pub_test = rospy.Publisher("/tote_drop", PoseStamped, queue_size=5, latch=True)
    status_pub = rospy.Publisher("/demo_status", String, queue_size=5, latch=True)
    TOTE_APPROACH_POSE.header.stamp = rospy.Time.now()
    pose_pub_test.publish(TOTE_APPROACH_POSE)
    simulation = rospy.get_param("/use_sim_time", False)
    State.simulation = simulation
    robot = Tahoma(simulation)
    print("here")
    demo_sm = StateMachine(["done"], input_keys=[], output_keys=[])
    pick_sm = StateMachine(["done"], input_keys=["request"], output_keys=[])
    stow_sm = StateMachine(["done"], input_keys=["request"], output_keys=[])

    # stows = [["4f", "mouthwash"], ["4f", "soda"], ["4f", "syrup"]]
    # stows = [["3f", "mouthwash"], ['3f', 'lysol'], ['2f', 'box']]
    # picks = [["3f", "lysol"], ['2f', 'box'], ['3f', 'mouthwash']]


    with demo_sm:

        with pick_sm:
            cf.splat_auto("SPLAT_PICK", "request", ["target_bin_id", "target_object_id"])
            StateMachine.add_auto("CLEAR_SCENE_PREMOVE", motion.ClearCollisionGeometry(robot), ["succeeded", "aborted"])
            StateMachine.add_auto("SETUP_COLLISION_SCENE_PREMOVE", motion.AddFullPodCollisionGeometry(robot), ["succeeded", "aborted"])
            StateMachine.add("GET_GRASP_POSE", perception.GetGraspPose(robot.tf2_buffer, pre_grasp_offset=.125),    
                            {"succeeded": "REMAP_PRE_GRASP_POSE", "aborted":"PASS", "preempted":"PASS"})
            StateMachine.add("PASS", PublishStatus(status_pub), {"succeeded": "done"})
            StateMachine.add_auto("REMAP_PRE_GRASP_POSE", cf.input_to_output("pre_grasp_pose", "pose"), ["succeeded"])
            StateMachine.add_auto("MOVE_TO_PRE_GRASP", motion.MoveEndEffectorToPose(robot), ["succeeded", "aborted", "preempted"])
            # StateMachine.add_auto("OPEN_BEFORE_GRASP", motion.OpenGripper(robot, return_before_done=True), ["succeeded", "aborted", "preempted"])
            StateMachine.add_auto("CLEAR_SCENE_PREGRASP", motion.ClearCollisionGeometry(robot), ["succeeded", "aborted"])
            StateMachine.add_auto("SETUP_COLLISION_SCENE_PREGRASP", motion.AddPartialPodCollisionGeometry(robot), ["succeeded", "aborted"])
            StateMachine.add_auto("MOVE_TO_GRASP", grasp_move_to_offset(robot, (0, 0, 0.300)), ["succeeded", "aborted", "preempted"])
            StateMachine.add_auto("LIFT_OBJ", robust_move_to_offset(robot, (0, 0, 0.035), 'base_link'), ["succeeded", "aborted", "preempted"])
            StateMachine.add_auto("RETRACT_ARM", robust_move_to_offset(robot, (0, 0, -0.35)), ["succeeded", "aborted", "preempted"])
            StateMachine.add_auto("CLEAR_SCENE_POSTGRASP", motion.ClearCollisionGeometry(robot), ["succeeded", "aborted"])
            StateMachine.add_auto("SETUP_COLLISION_SCENE_POSTGRASP", motion.AddFullPodCollisionGeometry(robot), ["succeeded", "aborted"])
            StateMachine.add_auto("ADD_IN_HAND_COLLISION_BOX", motion.AddInHandCollisionGeometry(robot), ["succeeded", "aborted"])
            StateMachine.add_auto("MOVE_TO_PRE_TOTE_POSE", motion.MoveToJointAngles(robot, "drop_hide"), ["succeeded", "aborted"])
            StateMachine.add_auto("PICTURE_WAIT", Wait(2), ["succeeded"])
            StateMachine.add("CHECK_FOR_GRIPPER_ITEM", motion.CheckGripperItem(robot), 
                            {"item_detected": "POST_PICK_UPDATE_MASKS", "no_item_detected": "UPDATE_BIN_MASKS"})
            StateMachine.add("POST_PICK_UPDATE_MASKS", perception.PickObject(),
                            {"succeeded": "ASK_FOR_GRIPPER_OPEN_TOTE_RELEASE", "aborted": "ASK_FOR_GRIPPER_OPEN_TOTE_RELEASE", "preempted": "ASK_FOR_GRIPPER_OPEN_TOTE_RELEASE"})
            StateMachine.add("UPDATE_BIN_MASKS", perception.UpdateBin(),
                            {"succeeded": "ASK_FOR_GRIPPER_OPEN_TOTE_RELEASE", "aborted": "ASK_FOR_GRIPPER_OPEN_TOTE_RELEASE", "preempted": "ASK_FOR_GRIPPER_OPEN_TOTE_RELEASE"})
            StateMachine.add("ASK_FOR_GRIPPER_OPEN_TOTE_RELEASE", motion.OpenGripper(robot, return_before_done=True), {"succeeded": "done", "aborted": "done", "preempted": "done"})


        with stow_sm:   
            cf.splat_auto("SPLAT_STOW", "request", ["target_bin_id", "target_object_id"])
            StateMachine.add("MOVE_TO_HIDE", motion.MoveToJointAngles(robot, "drop_hide"),
                            {"succeeded": "PRE_PERCEIVE", "aborted": "PICK_FAILED"})
            StateMachine.add("PRE_PERCEIVE", perception.CaptureEmptyBin(),
                            {"succeeded": "POST_PERCEIVE", "aborted": "PICK_FAILED", "preempted": "PICK_FAILED"})
            # StateMachine.add("ASK_FOR_BIN_LOAD", interaction.AskForHumanAction(),
            #                 {"succeeded": "POST_PERCEIVE", "aborted": "PICK_FAILED"})
            StateMachine.add("POST_PERCEIVE", perception.StowObject(),
                            {"succeeded": "PICK_SUCCESS", "aborted": "PICK_FAILED", "preempted": "PICK_FAILED"})
            cf.inject_userdata("PICK_FAILED", "done", "status", False)
            cf.inject_userdata("PICK_SUCCESS", "done", "status", True)



        StateMachine.add_auto("CLEAR_SCENE", motion.ClearCollisionGeometry(robot), ["succeeded", "aborted"])
        StateMachine.add_auto("SETUP_COLLISION_SCENE", motion.AddFullPodCollisionGeometry(robot), ["succeeded", "aborted"])
        StateMachine.add_auto("MOVE_TO_HIDE", motion.MoveToJointAngles(robot, "drop_hide"),  ["succeeded", "aborted"])
        StateMachine.add_auto("CHECK_GRIPPER_CLOSE", motion.CloseGripper(robot, return_before_done=True), ["succeeded", "aborted", "preempted"])
        StateMachine.add_auto("CHECK_GRIPPER_OPEN", motion.OpenGripper(robot, return_before_done=True), ["succeeded", "aborted", "preempted"])
        StateMachine.add_auto("CAPTURE_EMPTY_POD", perception.CaptureEmptyPod(),  ["succeeded"])
        StateMachine.add("WAIT_FOR_COMMAND", WaitForPickStow(), {"stow": "STOW", "pick":"PICK"})
        StateMachine.add("PICK", pick_sm, {"done": "WAIT_FOR_COMMAND"})
        StateMachine.add("STOW", stow_sm, {"done": "WAIT_FOR_COMMAND"})

    rospy.loginfo('Beginning demo SM')

    sis = smach_ros.IntrospectionServer('demo_sm', demo_sm, '/pick')
    sis.start()

    outcome = demo_sm.execute()

    rospy.spin()
    sis.stop()


if __name__ == '__main__':
    main()


