#!/usr/bin/env python

import smach_ros
import std_msgs
from smach import State, StateMachine
import rospy
import numpy as np
from geometry_msgs.msg import PoseStamped, Pose, Point, Quaternion
from tf_conversions import transformations
import tf2_ros
from aurmr_tasks.common.tahoma import Tahoma
from aurmr_tasks.common import perception
from aurmr_tasks.common import motion_storm as motion
from aurmr_tasks.common import states
from aurmr_tasks.common import control_flow as cf
from aurmr_tasks.msg import PickStatus



class PublishStatus(State):
    def __init__(self, publisher, wait_time=0):
        State.__init__(self, outcomes=['succeeded'], input_keys=["status", "start_time", "target_object_id"])
        self.publisher=publisher
        self.wait_time = wait_time
    def execute(self, userdata):
        now = rospy.get_rostime()
        now = now.secs + now.nsecs*10**(-9)
        time_delta = now - userdata["start_time"] 


        msg = PickStatus()
        msg.status = userdata["status"]
        msg.object_id = userdata["target_object_id"]
        msg.time = time_delta
        # self.publisher.publish("test")
        self.publisher.publish(msg)
        rospy.sleep(self.wait_time)
        return "succeeded"

class RecordTime(State):
    def __init__(self):
        State.__init__(self, outcomes=['succeeded'], output_keys=["start_time"])
    
    def execute(self, userdata):
        now = rospy.get_rostime()
        userdata["start_time"] = now.secs + now.nsecs*10**(-9)
        return "succeeded"


def read_waypoints_from_file(filename):

    lines = []
    waypoints = []

    with open(filename) as file:
        for line in file:
            lines.append(line.rstrip())

        for i in range(len(lines) // 4):
            str0 = lines[i * 4].split(' ')
            str1 = lines[i * 4 + 1].split(' ')
            str2 = lines[i * 4 + 2].split(' ')

            pose_stamped = PoseStamped()
            pose_stamped.header=std_msgs.msg.Header(frame_id=str2[1])

            pose = Pose()

            quat_arr = transformations.quaternion_from_euler(float(str1[1]), float(str1[2]), float(str1[3]))
            quat_obj = Quaternion(x=quat_arr[0], y=quat_arr[1], z=quat_arr[2], w=quat_arr[3])
            pose.orientation = quat_obj

            point = Point(x=float(str0[1]), y=float(str0[2]),z=float(str0[3]))
            pose.position = point

            pose_stamped.pose = pose

            waypoints.append(pose_stamped)
    
    return waypoints

def main():

    # init node and robot
    rospy.loginfo('Getting robot resources')
    rospy.init_node("travel_waypoints")
    #robot = Tahoma()

    # read waypoints from text file
    #WAYPOINTS = read_waypoints_from_file('waypoints.txt')   

    # WAYPOINTS_2 = [] 
    # for i in range (5):
    #     pose_stamped = PoseStamped()
    #     pose_stamped.header=std_msgs.msg.Header(frame_id='pod_base_link')
    #     pose = Pose()
    #     quat_obj = Quaternion(x=0, y=1, z=0, w=0)
    #     pose.orientation = quat_obj
    #     point = Point(x=0.33, y=1.23, z=-0.4-0.06*i)
    #     pose.position = point
    #     pose_stamped.pose = pose
    #     WAYPOINTS_2.append(pose_stamped) 
    


    pose_drop = PoseStamped()
    pose_drop.header=std_msgs.msg.Header(frame_id='pod_base_link')
    pose_drop.pose.orientation = Quaternion(0, 0.7071068, 0, 0.7071068)
    pose_drop.pose.position = Point(x=0.4, y=0.4, z=0.8)
  

    # For storm robot frame
    # pose_drop = PoseStamped()
    # pose_drop.header=std_msgs.msg.Header(frame_id='pod_base_link')
    # pose_drop.pose.orientation = Quaternion(0.7071068, 0, 0, 0.7071068)
    # pose_drop.pose.position = Point(x=0.0, y=0.35, z=1.08)

    # For baselink frame
    # pose_drop = PoseStamped()
    # pose_drop.header=std_msgs.msg.Header(frame_id='pod_base_link')
    # pose_drop.pose.orientation = Quaternion(x=0.7512804, y=0, z=0, w=0.6599831)
    # pose_drop.pose.position = Point(x=0.6, y=0.95, z=0.1)

    # pose_pre_grasp = PoseStamped()
    # pose_pre_grasp.header=std_msgs.msg.Header(frame_id='pod_base_link')
    # pose_pre_grasp.pose.orientation = Quaternion(x=0, y=1, z=0, w=0)
    # pose_pre_grasp.pose.position = Point(x=0.33, y=1.23, z=-0.4)

    # pose_in_pod = PoseStamped()
    # pose_in_pod.header=std_msgs.msg.Header(frame_id='pod_base_link')
    # pose_in_pod.pose.orientation = Quaternion(x=0, y=1, z=0, w=0)
    # pose_in_pod.pose.position = Point(x=0.33, y=1.23, z=-0.64)


    # pose_pre_grasp_up = PoseStamped()
    # pose_pre_grasp_up.header=std_msgs.msg.Header(frame_id='pod_base_link')
    # pose_pre_grasp_up.pose.orientation = Quaternion(x=0, y=1, z=0, w=0)
    # pose_pre_grasp_up.pose.position = Point(x=0.33, y=1.26, z=-0.4)

    # pose_in_pod_up = PoseStamped()
    # pose_in_pod_up.header=std_msgs.msg.Header(frame_id='pod_base_link')
    # pose_in_pod_up.pose.orientation = Quaternion(x=0, y=1, z=0, w=0)
    # pose_in_pod_up.pose.position = Point(x=0.33, y=1.26, z=-0.64)


    # print(f"{len(WAYPOINTS)} of {len(WAYPOINTS)} waypoints are approachable")
    simulation = rospy.get_param("~simulation", False)

    State.simulation = simulation

    pick_sm = StateMachine(["succeeded", "preempted", "aborted"],
                           input_keys=[],
                           output_keys=[])


    tf2_buffer = tf2_ros.Buffer()
    tf2_listener = tf2_ros.TransformListener(tf2_buffer)
    status_pub = rospy.Publisher("/demo_status", PickStatus, queue_size=5, latch=True)
    
    with pick_sm:
        # cf.inject_userdata_auto("LOAD_POSES_PICK", "poses_pick", WAYPOINTS_2[0:1])
        # cf.inject_userdata_auto("LOAD_POSES_DROP", "poses_drop", WAYPOINTS_2[::-1])
        StateMachine.add('INIT_POSE',
                              motion.MoveEndEffectorToPoseStorm(pose_drop),
                              {"succeeded": "succeeded", "aborted": "aborted"})

        # StateMachine.add('INIT_POSE',
        #                       motion.MoveEndEffectorToPoseStorm(pose_drop),
        #                       {"succeeded": "MOVE_TO_PRE_GRASP", "aborted": "MOVE_TO_PRE_GRASP"})
        # StateMachine.add("PICK_POSE", cf.IterateList("poses_pick", "pose"),
        #                  {"repeat": "MOVE_TO_POSE_PICK", "done": "MOVE_TO_POSE_Line"})
        
        
        # StateMachine.add('MOVE_TO_PRE_GRASP',
        #                       motion.MoveEndEffectorToPoseStorm(pose_pre_grasp),
        #                       {"succeeded": "PAUSE_00", "aborted": "PAUSE_00"})
        # StateMachine.add("PAUSE_00", states.Wait(1), {"succeeded": "MOVE_INTO_POD"})
        # StateMachine.add('MOVE_INTO_POD',
        #                       motion.MoveEndEffectorInLineStorm(pose_pre_grasp, pose_in_pod, use_force=True, use_gripper=True),
        #                       {"succeeded": "PAUSE_01", "aborted": "PAUSE_01"})
        # StateMachine.add("PAUSE_01", states.Wait(1), {"succeeded": "MOVE_UP_POD"})
        # StateMachine.add('MOVE_UP_POD',
        #                       motion.MoveEndEffectorInLineStorm(pose_in_pod, pose_in_pod_up, use_force=False, use_gripper=False, use_curr_pose=True),
        #                       {"succeeded": "PAUSE_02", "aborted": "PAUSE_02"})
        # StateMachine.add("PAUSE_02", states.Wait(1), {"succeeded": "MOVE_OUT_POD"})
        # StateMachine.add('MOVE_OUT_POD',
        #                       motion.MoveEndEffectorInLineStorm(pose_in_pod_up, pose_pre_grasp_up, use_force=False, use_gripper=False, use_curr_pose=True),
        #                       {"succeeded": "DROP_POSE", "aborted": "DROP_POSE"})
        # StateMachine.add('DROP_POSE',
        #                       motion.MoveEndEffectorToPoseStorm(pose_drop),
        #                       {"succeeded": "OPEN_GRIPPER", "aborted": "OPEN_GRIPPER"})
        # StateMachine.add('OPEN_GRIPPER',
        #                       motion.OpenGripperStorm(),
        #                       {"succeeded": "succeeded", "aborted": "aborted"})                      


    # Create top state machine
    sm = StateMachine(outcomes=['succeeded', "preempted", 'aborted'])

    with sm:
        StateMachine.add('STORM_POSE_SEQUENCE', pick_sm, {"succeeded": "succeeded", "aborted": "aborted"})

    rospy.loginfo('Beginning storm SM')

    sis = smach_ros.IntrospectionServer('pick_sm', sm, '/pick')
    sis.start()
    outcome = sm.execute()
    rospy.loginfo('Stop state machine')
    # rospy.spin()
    sis.stop()


if __name__ == '__main__':
    main()